headers = pthread.h
---
extern int xx(void *env, void * clazz);
static void * nrTest= &xx;

struct iovect {
    long  iov_base;
    int  iov_len;
};

struct iovect * convertAddressToBuffers(long address){
    struct iovect *iovp = (struct iovect *)address;
    return iovp;
}

pthread_mutex_t mutex;

typedef struct {
    char **array;
    size_t used;
    size_t size;
} MessageQueue;

MessageQueue *messageQu;


void createQueue() {
    pthread_mutex_init(&mutex, NULL);
    static MessageQueue data;
    (void) memset((void *) &data, 0, sizeof(data));
    messageQu = &data;
    messageQu->array = (char **) malloc(1 * sizeof(char *));
    messageQu->used = 0;
    messageQu->size = 1;
    messageQu->array[0] = NULL;
}

MessageQueue *get() {
    return messageQu;
}

void addMessage(char *element) {

    //pthread_mutex_lock(&mutex);
    if (messageQu->used == messageQu->size) {
        messageQu->size *= 2;
        messageQu->array = (char **) realloc(messageQu->array, messageQu->size * sizeof(char *));
    }
    size_t i = messageQu->used++;
    messageQu->array[i] = element;
    //pthread_mutex_unlock(&mutex);

}


void wsLock(){
  pthread_mutex_lock(&mutex);
}
void wsUnlock(){
  pthread_mutex_unlock(&mutex);
}

int size(){
    pthread_mutex_lock(&mutex);
    int s = messageQu->used;
    pthread_mutex_unlock(&mutex);
    return s;
}


char *first() {
    if (messageQu->used == 0) {
        return NULL;
    }
   return messageQu->array[0];
}

char *getMessage() {
    if (messageQu->used == 0) {
        pthread_mutex_unlock(&mutex);
        return NULL;
    }
    pthread_mutex_lock(&mutex);
    char *string = messageQu->array[0];
    messageQu->used = messageQu->used - 1;

    for (int i = 0; i < messageQu->size; i++) {
        messageQu->array[i] = messageQu->array[i + 1];
    }
    messageQu->array = (char **) realloc(messageQu->array, messageQu->size * sizeof(char *));
    pthread_mutex_unlock(&mutex);
    return string;
}


typedef struct {
 char* drillInstallationDir;
 void* di;
 void* xx;
} configStruct;

configStruct config;


pthread_mutex_t diMutex = PTHREAD_MUTEX_INITIALIZER;









typedef struct {
    unsigned char *array;
    int size;
} classd;

typedef struct {
    classd **array;
    size_t used;
    size_t size;
} ClassLoadingQueue;

ClassLoadingQueue *classLoadingQu;


void createClassLoadingQueue() {
    ClassLoadingQueue data;
    (void) memset((void *) &data, 0, sizeof(data));
    classLoadingQu = &data;
    classd **ptr = (classd **) malloc(1 * sizeof(classd));

    classLoadingQu->array = ptr;
    classLoadingQu->used = 0;
    classLoadingQu->size = 1;
    classLoadingQu->array[0] = NULL;

}

ClassLoadingQueue *getQs() {
    return classLoadingQu;
}

void addClass(unsigned char *element, int size) {
   //pthread_mutex_lock(&diMutex);
   //static classd aa;
   //(void) memset((void *) &aa, 0, sizeof(aa));
   //aa.array = element;
   //aa.size = size;
   //if (classLoadingQu->used == classLoadingQu->size) {
   //    classLoadingQu->size *= 2;
   //    classLoadingQu->array = (classd **) realloc(classLoadingQu->array, classLoadingQu->size * sizeof(classd));
   //}
   ////size_t i = classLoadingQu->used++;
   ////classLoadingQu->array[i] = &aa;
   //pthread_mutex_unlock(&diMutex);

}

classd *getLoadedClass() {
    pthread_mutex_lock(&diMutex);
    if (classLoadingQu->used == 0) {
        pthread_mutex_unlock(&diMutex);
        return NULL;
    }
    classd *string = classLoadingQu->array[0];
    classLoadingQu->used = classLoadingQu->used - 1;

    for (int i = 0; i < classLoadingQu->size; i++) {
        classLoadingQu->array[i] = classLoadingQu->array[i + 1];
    }
    classLoadingQu->array = (classd **) realloc(classLoadingQu->array, classLoadingQu->size * sizeof(classd));

    return string;
}

void anyLock(){
  pthread_mutex_lock(&diMutex);
}
void anyUnlock(){
  pthread_mutex_unlock(&diMutex);
}